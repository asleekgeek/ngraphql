<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NGraphQL</name>
    </assembly>
    <members>
        <member name="T:NGraphQL.CodeFirst.ErrorCodes">
            <summary>Defines values for error type. The error type is reported 
            in the error.Extensions dictionary under the key "code". </summary>
        </member>
        <member name="M:NGraphQL.CodeFirst.GraphQLModule.FromMap``1(System.Object)">
            <summary>A fake method, placeholder. Use it in mapping expressions (MapEntity() method) to identify the automatic conversion
            from entity to GraphQL type based on registered type mappings. </summary>
            <typeparam name="T">Target type.</typeparam>
            <param name="value">The value to convert.</param>
            <returns>Default value for type. The method should never be invoked directly.</returns>
        </member>
        <member name="T:NGraphQL.CodeFirst.DeprecatedDirAttribute">
            <summary>Marks type, field or parameter as deprecated. The element in schema document will appear with @deprecated
            directive.</summary>
        </member>
        <member name="T:NGraphQL.CodeFirst.GraphQLNameAttribute">
            <summary>Specifies the name of GraphQL schema element (type or field) explicitly. </summary>
        </member>
        <member name="T:NGraphQL.CodeFirst.NullAttribute">
            <summary>Marks the value as nullable. The mapped GraphQL type will not have a not-null marker (!). </summary>
        </member>
        <member name="T:NGraphQL.CodeFirst.WithNullsAttribute">
            <summary>Marks a list as possibly containing null values. The mapped GraphQL type will not have a non-null
            marker for the element type.  </summary>
            <remarks>
              Example: 
                int[] x; -&gt; [Int!]!
                [WithNulls] int[] x; -&gt; [int]!
            </remarks>
        </member>
        <member name="T:NGraphQL.CodeFirst.ScalarAttribute">
            <summary>Identifies the name of the Scalar to use as a type for the member. </summary>
        </member>
        <member name="T:NGraphQL.CodeFirst.IgnoreAttribute">
            <summary>Instructs the engine to completely ignore this member on .NET type. </summary>
        </member>
        <member name="T:NGraphQL.CodeFirst.HiddenAttribute">
            <summary>Marks element as hidden, not showing up in the Schema document. </summary>
            <remarks>All introspection types and hidden field __typename use this attribute.</remarks>
        </member>
        <member name="P:NGraphQL.CodeFirst.IRequestContext.CustomData">
            <summary>Values for use by app code - resolvers etc. </summary>
        </member>
        <member name="P:NGraphQL.CodeFirst.IRequestContext.HttpContext">
            <summary>Protocol context; for HTTP server - HttpContext instance (ASP.NET Core). </summary>
        </member>
        <member name="P:NGraphQL.CodeFirst.IRequestContext.VitaOperationContext">
            <summary>Reserved for VITA ORM operation context, assigned by VitaWebMiddleware. </summary>
        </member>
        <member name="T:NGraphQL.CodeFirst.ResolvesFieldAttribute">
            <summary>Specifies the field of ObjectType for a resolver method. This attribute is the opposite 
            of the Resolver attibute, which is put on object field and specifies the resolver method. </summary>
            <remarks>You can use either this attribute or Resolver attribute to link the field and its resolver. 
            We encourage you to use Resolves attibute (this one) to keep clear the object types from resolver 
            references (which are server-side classes) - even if by name only, so that these types can be used 
            in strongly-typed clients. 
            </remarks>
        </member>
        <member name="T:NGraphQL.CodeFirst.ResolverAttribute">
            <summary>Specifies the resolver method for a field of an Object GraphQL type. We encourage to use 
            the Resolves attribute instead of this attribute. </summary>
        </member>
        <member name="F:NGraphQL.Introspection.__Type.DisplayName">
            <summary>Full type spec, ex: [Int!]! .</summary>
        </member>
        <member name="M:NGraphQL.Model.DirectiveRegistrationExtensions.RegisterDirectiveHandler(NGraphQL.CodeFirst.GraphQLModule,System.String,System.Type)">
            <summary>Registers a type of handler for a directive that is already registered, possibly in another module. </summary>
            <param name="module">GraphQL module.</param>
            <param name="name">Directive name.</param>
            <param name="handlerType">Handler type.</param>
            <remarks>The purpose of this method is to allow registering handlers separately from the directives themselves.
            You can have a directive defined in light-weight module not dependent on any server-side assemblies, so it can be 
            used in client-side code. The directive's handler can be registered in server-side assembly, as it likely 
            needs access to server-side functionality. 
            </remarks>
        </member>
        <member name="T:NGraphQL.Model.EnumHandler">
            <summary>Handles conversions of enum values: to/from CLR enums vs stings and string arrays in GraphQL. </summary>
        </member>
        <member name="T:ImplementsAttribute">
            <summary> Specifies list of interfaces implemented by an interface or Object type. </summary>
            <remarks> One way to specify that GraphQL type implements an interface is to simply make the .NET type for Object type
            implement the corresponding interface. However, c# requires that exact match (member names, types) between
            interface and implementing type. GraphQL has weaker requirement, types can be covariant. 
            
            </remarks>
        </member>
    </members>
</doc>
